設計模式
=======

* 模式就是一種相似經驗的歸納
* 模式描述相似的問題應該如何解決
* 模式名稱是簡化溝通用的術語
* Design for Change

應用時機
-------

* 設計階段就知道問題可用哪個模式解決
* 重構時發現程式結構偏向哪個模式

注意事項
-------

* 設計時,遵守物件導向設計原則
* 撰寫程式碼時別去想模式,先專心處理問題
* 如果目的明確，一開始可以考慮用模式設計
* 比較好的方式是讓程式透過重構漸漸來接近模式

### Strategy

* 需求的變化可能更多,可能不是單靠 switch 就能處理
* 一旦需求必須改回來,還得再改一次程式
* 需要將會改變的規則或演算法抽離出來的場合
* 抽離出來的規則或演算法可以隨時抽換，而不會改動到使用主要程式的程式碼
* 同一演算法有不同版本 (例如執行時間/所需空間的不同)

### Simple Factory

* 封裝了 switch
* 靠外在變數決定要使用哪個類別
* 隔離建立物件的邏輯
* 建立出來的物件是同一個類別體系
* 繼承於相同抽象類的子類別群
* 如果在用戶端以 new 關鍵字來具現的話，就不容易改變；因為我們必須把類別名稱寫死在程式裡
* 外部呼叫的程式需要知道很多子類別
* 將實體化的責任交給單一類別
* PHP 可以採用變數來指定類別，移除對 switch 的依賴

### Singleton

* 整個執行過程中，只需要一個實體
* private consturctor
* 測試時要提供 reset 方法

### Chain of Responsibility

* 範例：購物車計價
* 購物車可以加入商品
* 透過商品序號找出價格
* 檢查每一項商品，符合規則的就被挑出計算
* 將要做的工作單元串成一個鎖鏈
* 將資料拋給第一個工作單元
* 符合條件的資料就會被該工作單元處理
* 不符合條件的資料就會被轉向下一個工作單元
* 最後有可能出現沒被處理的資料

### Observer

* 會員註冊時，可能會同時把會員資料寫入 Web 端資料庫、贈送折價券、寄發通知信等
* 客戶經常會改變這裡的動作像是在註冊完成後，透過 API 更新到客戶新建立的 ERP 系統
* 有什麼方法可以不必更動 save 方法,而可以擴充它
* 開放與關閉原則
* 物件狀態更新時，同時執行其他功能
* 提供程式可以動態加入或移除物件對它的監聽
* 可以讓 Observer 只監聽有興趣的事件
* 注意過於頻繁地呼叫 notify 方法,造成重複 update

### Template Method

* 資料排序
* 在 PHP 原始碼裡，陣列排序的方法 (zend_hash_sort) 提供了我們一個勾子
* sort 方法是使用預設的勾子 (array_data_compare)
* 我們可以透過這個勾子替換陣列排序的順序
* 演算法或流程大致相同,但實作細節不同
* 父類別的流程 (或演算法) 也是實作的一種
* 實作細節有越多的不同,我們的流程就可以切得越細，提供更多勾子 (hook)
* Don't call me, I call you. (好萊塢守則)
* 畫主線，帶勾，旁邊小類一堆卡片

### Composite

* 樹狀型的權限系統中，如何讓使用者加入群組，而群組也可以加入群組?
* 如何更直覺地呈現樹狀架構?
* Liskov 替換原則
* 可以用一致的方式來操作群組與個體
* 很適合用來處理樹狀結構
* 要小心別讓群組自己 add 到自己或自己的上一層，以避免無限遞迴
* 所以可以在物件裡保留一份對上一層群組的參考

### Iterator

* 迭代資料
* 封裝資料結構內部的運作
* SPL
  - http://www.php.net/manual/en/spl.iterators.php

### Bridge

* 一般是抽象，一邊是應用
* 兩邊可以各自演化，只要注意實作能使用到抽象的功能
* 範例： Cache System
  - 前端：頁面，資料
  - 後端：檔案， Memcached

### Adapter

* 包裝第三方套件來跟現有的系統介面整合
* 不會加入新的介面，而是把第三方套件的介面跟現有系統的介面之間做轉接的動作而已
